// -*- c -*-

requires 2.0.0

%h{
%}

%privateheader{
#include "cf_rcfile.h"
#include "local_server.h"
#include "log-db.h"
#include "sa_array.h"
#include "up_uploader.h"

#include "common/evq_event.h"

  ClientCl2* getGlobalClient();

#define cf_STATIC_GET(key) \
  (cf_RcFile_get_##key(getGlobalClient()->_priv->rcFile))
%}

%{
#include "application_config.h"
#include "utils_cl2.h"

#include "common/assertions.h"
#include "common/error_list.h"
#include "common/logging.h"
#include "common/platform_config.h"
#include "common/utilities.h"

static ClientCl2* globalClient = NULL;

 ClientCl2* getGlobalClient() {
   return globalClient;
 }
%}

class Client:Cl2 from G:Object {
  private LogDb* log = NULL; // owned

  private cf_RcFile* rcFile = NULL; // owned

  private sa_Array* scanner = NULL; // owned

  private LocalServer* localServer = NULL; // owned

  private up_Uploader* uploader = NULL; // owned

  // This queue is passed to the subcomponents of this component, to
  // enable them to do event delivery.
  // 
  // The caller may interact directly with the event loop by calling
  // event_loop and event_loop_stop as desired. Of course, the
  // event_loop_stop will have to originate from a different thread,
  // since event_loop does not return before a call to
  // event_loop_stop. There may also be alternative ways of
  // interacting with the event loop; particularly on Symbian there is
  // platform-provided machinery for doing that.
  // 
  // The event queue is owned by this component due to a shortcoming
  // in our event system. Basically, we must ensure that there are no
  // events originated by CL2 after the ClientCl2 instance has been
  // deleted. However, currently the only mechanism for doing this is
  // to invoke event_close, and this means that no one else will be
  // able to use the queue either any longer after that. Us owning the
  // queue here reflects this reality, but ideally the event queue
  // would encompass the entire application, and be passed to
  // ClientCl2 upon initialization. This anyway kind of is the
  // situation with the Symbian built in event mechanism, and
  // reflecting that design here would be more ideal.
  private EventQueue eventQueue;

  // Can add any initialization code here.
  // But there is no way of reporting errors from here.
  init (self) {
    UNLESS_SYMBIAN(event_init(&(self->_priv->eventQueue)));
  }

  // Creates the client "active object".
  public ClientCl2* new(GError** error)
  {
    assert_error_unset(error);

    ClientCl2* self = GET_NEW;
    globalClient = self;

    self->_priv->rcFile = cf_RcFile_new(error);
    if (!(self->_priv->rcFile)) {
      g_object_unref(self);
      return NULL;
    }

    LogDb* log = log_db_new(error);
    if (!log) {
      g_object_unref(self);
      return NULL;
    }
    self->_priv->log = log;

    if (!client_cl2_start_uploader(self, error)) {
      g_object_unref(self);
      return NULL;
    }

    sa_Array* scanner = sa_Array_new(&(self->_priv->eventQueue), log, error);
    if (!scanner) {
      g_object_unref(self);
      return NULL;
    }
    self->_priv->scanner = scanner;

    LocalServer* localServer = LocalServer_new(error);
    if (!localServer) {
      g_object_unref(self);
      return NULL;
    }
    self->_priv->localServer = localServer;

    return self;
  }

  // Destroys the client "active object".
  override (G:Object) void
    finalize (GObject *object)
    {
      Self *self = SELF(object);

      // This stops all event delivery, so the cleanup of the other
      // subcomponents must be synchronous, not depending on event
      // delivery.
      UNLESS_SYMBIAN(event_close(&(self->_priv->eventQueue)));

      LocalServer_destroy(self->_priv->localServer); // safe if NULL
      self->_priv->localServer = NULL;
      logt("local server destroyed");

      client_cl2_stop_uploader(self);

      // We sometimes get USER 42 here. Say the cellid sensor is
      // enough to make this happen, but uploader may also be
      // required.
      logt("invoking sa_Array_destroy");
      sa_Array_destroy(self->_priv->scanner);
      self->_priv->scanner = NULL;
      logt("scanner array destroyed");

      XDECREF(self->_priv->log);
      logt("LogDb session destroyed");

      cf_RcFile_destroy(self->_priv->rcFile);
      self->_priv->rcFile = NULL;

      PARENT_HANDLER(object);
      logt("logger controller destroyed");

      globalClient = NULL;
    } 

  private gboolean start_uploader(self, GError** error)
  {
#if __FEATURE_UPLOADER__
    assert(!self->_priv->uploader);
    self->_priv->uploader = up_Uploader_new(self->_priv->log, error);
    if (!self->_priv->uploader) {
      assert_error_set(error);
      return FALSE;
    }
#endif
    return TRUE;
  }

  private void stop_uploader(self)
  {
#if __FEATURE_UPLOADER__
    up_Uploader_destroy(self->_priv->uploader); // safe if NULL
    self->_priv->uploader = NULL;
    logt("uploader destroyed");
#endif
  }

  // Starts the client "active object". This starts the activities
  // (such as sensor scanning) of this component, but this does not
  // start event handling.
  public gboolean start(self, GError** error)
  {
    sa_Array_start(self->_priv->scanner);
    if (!LocalServer_start(self->_priv->localServer, error))
      return FALSE;
    return TRUE;
  }

  // Stops the client "active object". Stops all the activities of
  // this component, but does not affect event handling, which is
  // handled separately.
  public gboolean stop(self, GError** error)
  {
    LocalServer_stop(self->_priv->localServer);
    sa_Array_stop(self->_priv->scanner);
    return TRUE;
  }

  // A convenience method for running the event loop until an
  // interrupt event is delivered.
  public gboolean run(self, GError** error)
  {
#if defined(__SYMBIAN32__)
    { assert(0); return TRUE; }
#else
    return event_loop(&(self->_priv->eventQueue), error);
#endif /* __SYMBIAN32__ */
  }
}
